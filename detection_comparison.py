#!/usr/bin/env python3
"""
Detection Comparison Script
Compares different detection approaches and provides detailed analysis
"""

import os
import time
import json
import subprocess
import sys
from typing import Dict, List, Tuple
import matplotlib.pyplot as plt
import numpy as np

class DetectionComparator:
    def __init__(self):
        """Initialize detection comparator"""
        self.video_file = "vid.mov"
        self.results = {}
        self.comparison_data = {}
        
    def run_detection_script(self, script_name: str, description: str) -> Dict:
        """Run a detection script and capture results"""
        print(f"\nüî¨ Testing: {description}")
        print("-" * 40)
        
        start_time = time.time()
        
        try:
            # Run the script
            result = subprocess.run([sys.executable, script_name], 
                                  capture_output=True, text=True, timeout=300)
            
            execution_time = time.time() - start_time
            
            # Check if script completed successfully
            if result.returncode == 0:
                print(f"‚úÖ {description} completed successfully")
                
                # Try to find result files
                result_files = self._find_result_files(script_name)
                
                return {
                    'script': script_name,
                    'description': description,
                    'success': True,
                    'execution_time': execution_time,
                    'stdout': result.stdout,
                    'stderr': result.stderr,
                    'result_files': result_files
                }
            else:
                print(f"‚ùå {description} failed")
                return {
                    'script': script_name,
                    'description': description,
                    'success': False,
                    'execution_time': execution_time,
                    'stdout': result.stdout,
                    'stderr': result.stderr,
                    'result_files': []
                }
                
        except subprocess.TimeoutExpired:
            print(f"‚è∞ {description} timed out")
            return {
                'script': script_name,
                'description': description,
                'success': False,
                'execution_time': 300,
                'stdout': '',
                'stderr': 'Timeout after 5 minutes',
                'result_files': []
            }
        except Exception as e:
            print(f"‚ùå {description} error: {e}")
            return {
                'script': script_name,
                'description': description,
                'success': False,
                'execution_time': time.time() - start_time,
                'stdout': '',
                'stderr': str(e),
                'result_files': []
            }
    
    def _find_result_files(self, script_name: str) -> List[str]:
        """Find result files generated by a script"""
        base_name = script_name.replace('.py', '')
        result_files = []
        
        # Common result file patterns
        patterns = [
            f"{base_name}_results.json",
            f"{base_name}_detection_results.json",
            f"{base_name}_results/",
            f"{base_name}_output.mp4"
        ]
        
        for pattern in patterns:
            if os.path.exists(pattern):
                result_files.append(pattern)
        
        return result_files
    
    def load_json_results(self, file_path: str) -> Dict:
        """Load JSON results from a file"""
        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"‚ö†Ô∏è Could not load {file_path}: {e}")
            return {}
    
    def compare_detection_methods(self):
        """Compare all detection methods"""
        print("üîç COMPREHENSIVE DETECTION COMPARISON")
        print("=" * 60)
        
        # Check if video file exists
        if not os.path.exists(self.video_file):
            print(f"‚ùå Video file '{self.video_file}' not found!")
            return
        
        # Define detection methods to test
        detection_methods = [
            ("balanced_detection.py", "Balanced Detection (0.5 confidence)"),
            ("high_confidence_detection.py", "High Confidence Detection (0.7 confidence)"),
            ("enhanced_detection.py", "Enhanced Detection (temporal + tracking)"),
            ("ensemble_detection.py", "Ensemble Detection (multi-model)")
        ]
        
        # Run each detection method
        for script_name, description in detection_methods:
            if os.path.exists(script_name):
                result = self.run_detection_script(script_name, description)
                self.results[description] = result
            else:
                print(f"‚ö†Ô∏è Script {script_name} not found, skipping...")
        
        # Analyze results
        self.analyze_results()
        
        # Generate comparison report
        self.generate_comparison_report()
    
    def analyze_results(self):
        """Analyze detection results"""
        print(f"\nüìä ANALYZING RESULTS")
        print("=" * 60)
        
        for description, result in self.results.items():
            if not result['success']:
                continue
            
            # Load JSON results if available
            json_data = {}
            for file_path in result['result_files']:
                if file_path.endswith('.json'):
                    json_data = self.load_json_results(file_path)
                    break
            
            if json_data:
                self.comparison_data[description] = {
                    'execution_time': result['execution_time'],
                    'total_detections': json_data.get('total_detections', 0),
                    'total_frames': json_data.get('total_frames', 0),
                    'fps': json_data.get('fps', 0),
                    'class_counts': json_data.get('class_counts', {}),
                    'confidence_threshold': json_data.get('confidence_threshold', 0),
                    'processing_time': json_data.get('processing_time', 0)
                }
                
                print(f"\nüìà {description}:")
                print(f"   Execution time: {result['execution_time']:.2f}s")
                print(f"   Total detections: {json_data.get('total_detections', 0):,}")
                print(f"   Processing FPS: {json_data.get('fps', 0):.1f}")
                print(f"   Classes detected: {len(json_data.get('class_counts', {}))}")
                
                # Show top classes
                class_counts = json_data.get('class_counts', {})
                if class_counts:
                    top_classes = sorted(class_counts.items(), key=lambda x: x[1], reverse=True)[:3]
                    for class_name, count in top_classes:
                        print(f"     - {class_name}: {count:,}")
    
    def generate_comparison_report(self):
        """Generate comprehensive comparison report"""
        print(f"\nüìã GENERATING COMPARISON REPORT")
        print("=" * 60)
        
        # Create comparison summary
        comparison_summary = {
            'video_file': self.video_file,
            'comparison_timestamp': time.strftime("%Y-%m-%d %H:%M:%S"),
            'methods_tested': len(self.results),
            'successful_methods': len([r for r in self.results.values() if r['success']]),
            'method_comparisons': self.comparison_data,
            'raw_results': self.results
        }
        
        # Save comparison report
        with open('detection_comparison_report.json', 'w') as f:
            json.dump(comparison_summary, f, indent=2)
        
        # Generate text report
        self._generate_text_report(comparison_summary)
        
        print(f"\nüìÅ Comparison Report saved: detection_comparison_report.json")
        print(f"üìÑ Text Report saved: detection_comparison_report.txt")
    
    def _generate_text_report(self, comparison_summary: Dict):
        """Generate human-readable text report"""
        report_lines = []
        
        report_lines.append("üîç DETECTION METHODS COMPARISON REPORT")
        report_lines.append("=" * 60)
        report_lines.append(f"Video File: {comparison_summary['video_file']}")
        report_lines.append(f"Comparison Date: {comparison_summary['comparison_timestamp']}")
        report_lines.append(f"Methods Tested: {comparison_summary['methods_tested']}")
        report_lines.append(f"Successful Methods: {comparison_summary['successful_methods']}")
        report_lines.append("")
        
        # Performance comparison table
        report_lines.append("üìä PERFORMANCE COMPARISON")
        report_lines.append("-" * 40)
        report_lines.append(f"{'Method':<35} {'Detections':<12} {'FPS':<8} {'Time(s)':<8} {'Classes':<8}")
        report_lines.append("-" * 80)
        
        for description, data in comparison_summary['method_comparisons'].items():
            detections = f"{data['total_detections']:,}"
            fps = f"{data['fps']:.1f}"
            time_s = f"{data['execution_time']:.1f}"
            classes = f"{len(data['class_counts'])}"
            
            report_lines.append(f"{description:<35} {detections:<12} {fps:<8} {time_s:<8} {classes:<8}")
        
        report_lines.append("")
        
        # Detailed analysis
        report_lines.append("üîç DETAILED ANALYSIS")
        report_lines.append("-" * 40)
        
        for description, data in comparison_summary['method_comparisons'].items():
            report_lines.append(f"\nüìà {description}:")
            report_lines.append(f"   Total Detections: {data['total_detections']:,}")
            report_lines.append(f"   Processing FPS: {data['fps']:.1f}")
            report_lines.append(f"   Execution Time: {data['execution_time']:.2f} seconds")
            report_lines.append(f"   Classes Detected: {len(data['class_counts'])}")
            
            # Show class breakdown
            if data['class_counts']:
                report_lines.append("   Class Breakdown:")
                for class_name, count in sorted(data['class_counts'].items(), key=lambda x: x[1], reverse=True):
                    percentage = (count / data['total_detections']) * 100
                    report_lines.append(f"     - {class_name}: {count:,} ({percentage:.1f}%)")
        
        # Recommendations
        report_lines.append("\nüí° RECOMMENDATIONS")
        report_lines.append("-" * 40)
        
        # Find best method for different criteria
        if comparison_summary['method_comparisons']:
            # Best for speed
            fastest = min(comparison_summary['method_comparisons'].items(), 
                         key=lambda x: x[1]['execution_time'])
            report_lines.append(f"üöÄ Fastest Method: {fastest[0]} ({fastest[1]['execution_time']:.2f}s)")
            
            # Best for accuracy (most detections)
            most_detections = max(comparison_summary['method_comparisons'].items(), 
                                key=lambda x: x[1]['total_detections'])
            report_lines.append(f"üéØ Most Detections: {most_detections[0]} ({most_detections[1]['total_detections']:,})")
            
            # Best for efficiency (detections per second)
            most_efficient = max(comparison_summary['method_comparisons'].items(), 
                               key=lambda x: x[1]['total_detections'] / x[1]['execution_time'])
            detections_per_second = most_efficient[1]['total_detections'] / most_efficient[1]['execution_time']
            report_lines.append(f"‚ö° Most Efficient: {most_efficient[0]} ({detections_per_second:.1f} detections/sec)")
        
        # Save text report
        with open('detection_comparison_report.txt', 'w') as f:
            f.write('\n'.join(report_lines))
    
    def create_visualization(self):
        """Create visualization of comparison results"""
        try:
            import matplotlib.pyplot as plt
            
            if not self.comparison_data:
                print("‚ö†Ô∏è No comparison data available for visualization")
                return
            
            # Prepare data for plotting
            methods = list(self.comparison_data.keys())
            detections = [data['total_detections'] for data in self.comparison_data.values()]
            times = [data['execution_time'] for data in self.comparison_data.values()]
            fps = [data['fps'] for data in self.comparison_data.values()]
            
            # Create subplots
            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
            
            # Plot 1: Total Detections
            ax1.bar(methods, detections, color='skyblue')
            ax1.set_title('Total Detections by Method')
            ax1.set_ylabel('Number of Detections')
            ax1.tick_params(axis='x', rotation=45)
            
            # Plot 2: Execution Time
            ax2.bar(methods, times, color='lightcoral')
            ax2.set_title('Execution Time by Method')
            ax2.set_ylabel('Time (seconds)')
            ax2.tick_params(axis='x', rotation=45)
            
            # Plot 3: Processing FPS
            ax3.bar(methods, fps, color='lightgreen')
            ax3.set_title('Processing FPS by Method')
            ax3.set_ylabel('Frames per Second')
            ax3.tick_params(axis='x', rotation=45)
            
            # Plot 4: Efficiency (detections per second)
            efficiency = [d/t for d, t in zip(detections, times)]
            ax4.bar(methods, efficiency, color='gold')
            ax4.set_title('Detection Efficiency')
            ax4.set_ylabel('Detections per Second')
            ax4.tick_params(axis='x', rotation=45)
            
            plt.tight_layout()
            plt.savefig('detection_comparison_charts.png', dpi=300, bbox_inches='tight')
            plt.close()
            
            print(f"üìä Visualization saved: detection_comparison_charts.png")
            
        except ImportError:
            print("‚ö†Ô∏è matplotlib not available, skipping visualization")
        except Exception as e:
            print(f"‚ö†Ô∏è Error creating visualization: {e}")

def main():
    """Main function"""
    print("üîç Detection Methods Comparison Tool")
    print("=" * 50)
    
    # Initialize comparator
    comparator = DetectionComparator()
    
    # Run comparison
    comparator.compare_detection_methods()
    
    # Create visualization
    comparator.create_visualization()
    
    print(f"\n‚úÖ Comparison completed!")
    print(f"üìÅ Check the generated reports for detailed analysis")

if __name__ == "__main__":
    main()
